(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{147:function(e,t,a){"use strict";a.r(t);var n=a(0),s=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"移动端预览压缩上传图片"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#移动端预览压缩上传图片","aria-hidden":"true"}},[e._v("#")]),e._v(" 移动端预览压缩上传图片")]),e._v(" "),a("p",[e._v("移动端图片上传，通过FileReader生成base64图片资源进行预览，通过canvas进行图片的压缩，将图片url转换成Blob对象上传。")]),e._v(" "),a("h2",{attrs:{id:"实现方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现方案","aria-hidden":"true"}},[e._v("#")]),e._v(" 实现方案")]),e._v(" "),a("ul",[a("li",[e._v("初始页面布局")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<!DOCTYPE html>\n<html lang="en">\n<head>\n\t<meta charset="UTF-8">\n\t<title>图片上传</title>\n</head>\n\t<style>\t\n\t\timg{\n\t\t\tdisplay:block;\n\t\t\twidth:200px;\n\t\t}\n\t</style>\n<body>\n\t<input type="file" accept="image/*" multiple id="upload" onchange="previewImg(this,\'preview-img\')">\n\t<img src="" alt="" id="preview-img">\n</body>\n</html>\n')])])]),a("ul",[a("li",[e._v("移动端file有兼容上的问题，解决方案：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<input type="file" id="upload" class="upload" accept="image/*" multiple />\n')])])]),a("ul",[a("li",[e._v("使用FileReader进行图片预览")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/**\n * [previewImg 预览图片]\n * @param  {[type]} input [文件上传input]\n * @param  {[type]} obj   [description]\n * @return {[type]}       [description]\n */\nfunction previewImg(input,imgObj) {\n    var maxsize = 300 * 1024;//超过300k进行压缩\n    //是否支持\n    if (typeof FileReader === 'undefined') {\n        alert(\"抱歉，你的浏览器不支持 FileReader，请使用现代浏览器操作！\");\n        input.setAttribute('disabled','disabled');\n    }\n    if(input.files && input.files[0]){\n        var file = input.files[0],\n            reader = new FileReader();\n        if(file.type !== 'image/jpeg' && file.type !== 'image/png' && file.type !== 'image/gif') {\n            alert('不是有效的图片文件!');\n            return;\n        }\n        reader.readAsDataURL(file);\n        reader.onload = function(e){\n            var result =　this.result;//获取到base64的图片\n            //大于300k图片进行压缩\n            if(result.length >= maxsize){\n                var img = new Image();\n                img.src = result;\n                img.onload = function(){\n                    compressSrc = compress(img,0.8,100);\n                    $(imgObj).setAttribute('src',compressSrc);\n                    //ajax dataURLtoBlob(compressSrc);\n                }\n            }else{\n                $(imgObj).setAttribute('src',result);\n                //ajax dataURLtoBlob(result);\n            }\n        }\n    }\n}\n")])])]),a("ul",[a("li",[e._v("使用canvas图片压缩，不过在ios中图片大于2000000像素就无法使用canvas压缩，就需要瓦片绘制。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('/**\n * [compress 压缩图片]\n * @param  {[dom]} sourceImg [图片dom]\n * @param  {[int]0-1} scale     [缩小的尺寸比例]\n * @param  {[int]0-100} quality   [清晰质量]\n * @return {[object]}           [图片源]\n */\nfunction compress(sourceImg,scale,quality){\n    var area = sourceImg.width * sourceImg.height,//源图片的总大小\n        height = sourceImg.height * scale,\n        width = sourceImg.width * scale,\n        compressCvs = document.createElement(\'canvas\');//压缩的图片画布\n    //压缩的图片配置宽高\n    compressCvs.width = width;\n    compressCvs.height = height;\n    var compressCtx = compressCvs.getContext("2d");\n    //解决ios 图片大于2000000像素无法用drawImage的bug\n    if(area > 2000000 && navigator.userAgent.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/)){\n        //瓦片绘制\n        var smallCvs = document.createElement("canvas"),\n            smallCtx = smallCvs.getContext("2d"),\n            count = Math.ceil(area / 1000000),//分割的数量\n            cvsWidth = width / count,//每个小canvas的宽度\n            picWidth = sourceImg.width / count;//分割成小图片的宽度\n        smallCvs.height = compressCvs.height;\n        smallCvs.width =  width / count;\n        //拼凑成大的canvas\n        for(var i = 0;i < count;i ++){\n            smallCtx.drawImage(sourceImg,i*picWidth,0,picWidth,sourceImg.height,0,0,cvsWidth,height);\n            compressCtx.drawImage(smallCvs,i*cvsWidth,0,cvsWidth,height);\n        }\n    }else{\n        compressCtx.drawImage(sourceImg,0,0,sourceImg.width,sourceImg.height,0,0,width,height);\n    }\n    //将canvas转换成base64\n    return compressCvs.toDataURL(\'image/jpeg\',quality/100);\n}\nfunction $(id){\n    return document.getElementById(id);\n}\n')])])]),a("ul",[a("li",[e._v("将图片url转换为blob对象")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/**\n * [dataURLtoBlob 将base64转换为blob对象]\n * @param  {[type]} dataurl [图片源base64]\n * @return {[object]}         [图片源blob对象]\n */\nfunction dataURLtoBlob(dataurl) {\n    var arr = dataurl.split(','),\n        mime = arr[0].match(/:(.*?);/)[1],\n        bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);\n    while(n--){\n        u8arr[n] = bstr.charCodeAt(n);\n    }\n    return new Blob([u8arr], {type:mime});\n}\n")])])]),a("h2",{attrs:{id:"使用说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用说明","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用说明")]),e._v(" "),a("p",[e._v("这个只是一个移动端预览压缩上传图片实现的demo，会有一些兼容性和bug问题，大家可以自己修改和扩展，可以推荐一个比较成熟的解决方案："),a("a",{attrs:{href:"ttps://github.com/think2011/localResizeIMG"}},[e._v("传送门")])])])}],!1,null,null,null);s.options.__file="upload.md";t.default=s.exports}}]);